motor_driver:
  ros__parameters:
    i2c_bus: 1
    # Raspberry Pi 5 vendor library uses address 0x2B
    i2c_addr: 43  # 0x2B
    i2c_protocol: "auto"  # auto|pi5|legacy
    i2c_required: true
    dry_run: false
    max_pwm: 100
    # Helps all wheels start together at low commands (overcomes static friction).
    # If the robot creeps when you barely touch keys, reduce or set to 0.
    min_pwm: 15
    # Optional: brief boost when starting from rest to overcome wheel static friction.
    # Helps wheels start together on turns/strafe when some motors are "stickier" than others.
    # 0 disables.
    startup_kick_pwm: 0
    startup_kick_duration_sec: 0.15
    max_linear_velocity: 0.35   # m/s (tune for your robot)
    # Mecanum drive uses linear.x (forward), linear.y (left), angular.z (yaw)
    drive_mode: "mecanum"  # mecanum|differential

    # Geometry (meters). If you don't know these yet, start with ~0.18 and tune.
    wheel_separation: 0.18      # used by differential mode
    wheelbase: 0.18             # front-to-rear wheel distance
    track_width: 0.18           # left-to-right wheel distance

    # Motor mapping for pi5 protocol (0..3). Defaults assume:
    # 0=front_left, 1=rear_left, 2=front_right, 3=rear_right
    motor_id_fl: 0
    motor_id_rl: 1
    motor_id_fr: 2
    motor_id_rr: 3
    invert_fl: false
    # If a wheel spins backwards on forward commands, flip its invert_*. Often if one
    # right wheel is reversed you should flip BOTH right wheels (FR+RR) so they don't fight.
    invert_fr: false
    invert_rl: false
    invert_rr: false
    # I2C write rate. Too high can cause uneven updates; 20Hz is usually plenty.
    write_hz: 20.0
    cmd_vel_timeout_sec: 0.5
    idle_stop_period_sec: 1.0
    # PID heading-hold: uses IMU yaw heading + gyro rate to correct drift when
    # driving straight.  The integral term learns constant motor asymmetry so
    # subsequent drives are corrected immediately.
    gyro_heading_hold_enable: true
    gyro_heading_hold_gain: 1.2        # Kp: PWM per degree of heading error
    gyro_heading_hold_ki: 0.5          # Ki: integral (learns DC asymmetry)
    gyro_heading_hold_kd: 0.3          # Kd: derivative (gyro rate damping)
    gyro_heading_hold_max_correction: 30.0
    gyro_heading_hold_deadband_rad: 0.05
    gyro_heading_hold_integral_max: 20.0  # anti-windup limit (PWM·s)
    # Rotate-to-angle stability: keep heading-hold from kicking in as angular.z
    # gets small near the target.
    gyro_heading_hold_turn_disable_rad: 0.005
    gyro_heading_hold_turn_cooldown_sec: 0.25
    # Strafe pulsing mitigation
    # - Deadbands tiny heading corrections during pure strafe (reduces speed modulation)
    # - Slew-limits the final wheel PWMs during pure strafe (smooths output)
    gyro_heading_hold_strafe_correction_deadband_pwm: 1.5
    pwm_slew_rate_strafe: 500.0  # PWM/s (0 disables)
    # Correction sign: set to -1.0 if the heading-hold makes drift WORSE.
    # Watch the [heading-hold] diagnostic log: if "err" grows while "corr" is
    # non-zero, flip this sign.
    # NOTE: +1.0 is correct with BNO055 axis remap (firmware ≥2.1.0).
    heading_hold_sign: 1.0
    # Diagnostic log interval (seconds). Prints PID state periodically. 0 disables.
    heading_hold_diag_interval_sec: 2.0
    imu_topic: "imu/data"
    imu_yaw_topic: "imu/yaw_deg"

    # Adaptive motor trim: slowly extracts the DC component of the PID
    # correction as a persistent left/right offset.  Reduces PID load so the
    # controller can focus on transient disturbances.
    motor_trim_adapt_enable: true
    motor_trim_adapt_rate: 0.10        # PWM/s of adaptation (converges in ~10s)
    motor_trim_max: 15.0               # maximum learned trim offset

    # Per-motor manual trim (added to each wheel's PWM; positive = more speed).
    # Use these if you know a specific wheel is slower.
    trim_fl: 0.0
    trim_fr: 0.0
    trim_rl: 0.0
    trim_rr: 0.0

    # Lateral drift correction: uses accelerometer Y to detect sideways drift
    # and injects a mecanum strafe offset.  With BNO055, linear_acceleration
    # is gravity-subtracted, giving a clean signal for lateral drift detection.
    lateral_drift_correction_enable: true
    lateral_drift_gain: 2.0
    lateral_drift_max_correction: 8.0
    lateral_drift_alpha: 0.15          # low-pass filter coefficient

    # ── Collision failsafe (ultrasonic) ──────────────────────────────
    # Blocks forward motion when the ultrasonic sensor detects an obstacle.
    # Enabled by default.  Does NOT affect backward, strafe, or rotation.
    collision_failsafe_enable: true
    collision_stop_distance_m: 0.15    # hard stop (no forward motion)
    collision_slow_distance_m: 0.35    # begin linear slow-down
    collision_ultrasonic_topic: "ultrasonic/range"
    collision_failsafe_timeout_sec: 1.0  # ignore stale data after this long

    # ── LiDAR front-zone collision integration ───────────────────────
    # Complements the ultrasonic failsafe with 360° LiDAR data.
    # The motor driver uses min(ultrasonic, lidar_front) for the effective
    # collision distance, giving broader coverage.
    lidar_front_range_topic: "lidar/front_range"
    lidar_collision_enable: true
    lidar_collision_timeout_sec: 1.0

    # ── Cliff failsafe (line-tracker IR sensors) ─────────────────────
    # Blocks forward motion when any line-tracker sensor detects "no floor"
    # (i.e. an edge, cliff, or stair drop).  Enabled by default.
    # Sensor polarity: 1 = floor present, 0 = no floor / edge.
    # Does NOT affect backward, strafe, or rotation.
    cliff_failsafe_enable: false
    cliff_tracking_topic: "tracking/state"
    cliff_failsafe_timeout_sec: 1.0    # ignore stale data after this long
    cliff_sensor_mask: 15              # bitmask: L1=1 L2=2 R1=4 R2=8 (15 = all)

ultrasonic:
  ros__parameters:
    # auto will use I2C distance registers on Pi5 (0x2B) and GPIO trig/echo on legacy.
    mode: "auto"  # auto|i2c|gpio

    # Pi5 I2C ultrasonic (same controller as motors)
    i2c_bus: 1
    i2c_addr: 43  # 0x2B
    i2c_protocol: "auto"
    i2c_required: false
    dry_run: false

    gpio_backend: "auto"  # auto|rpi|lgpio
    gpio_mode: "BOARD"   # BOARD or BCM
    lgpio_chip: -1  # auto-select (Pi 5 often needs gpiochip4)
    trig_pin: 16
    echo_pin: 18
    frame_id: "ultrasonic_link"
    min_range_m: 0.02
    max_range_m: 4.0
    publish_hz: 10.0

gpio_sensors:
  ros__parameters:
    gpio_backend: "auto"  # auto|rpi|lgpio
    gpio_mode: "BOARD"
    lgpio_chip: -1  # auto-select (Pi 5 often needs gpiochip4)
    avoid_on_pin: 22
    avoid_left_pin: 21
    avoid_right_pin: 19
    tracking_left1_pin: 13
    tracking_left2_pin: 15
    tracking_right1_pin: 11
    tracking_right2_pin: 7
    publish_hz: 20.0

opencv_camera:
  ros__parameters:
    device_index: -1   # -1 = auto-detect USB webcam
    frame_id: "camera_link"
    width: 640
    height: 480
    fps: 30.0
    jpeg_quality: 80
    topic: "image_raw/compressed"

pi_camera:
  ros__parameters:
    # Capture backend: auto | gstreamer | v4l2
    # auto tries GStreamer (libcamerasrc) first, then V4L2
    backend: "auto"
    camera_index: 0
    v4l2_device_index: -1  # -1 = auto-discover (/dev/video10+)
    frame_id: "front_camera_link"
    width: 640
    height: 480
    fps: 30.0
    jpeg_quality: 80
    topic: "front_camera/compressed"
    # Autofocus (Pi Camera Module 3 / IMX708 PDAF)
    #   af_mode:  0 = manual, 1 = auto (single-shot), 2 = continuous
    #   af_range: 0 = normal, 1 = macro, 2 = full
    #   af_speed: 0 = normal, 1 = fast
    # Continuous + full-range + fast is ideal for a moving robot.
    af_mode: 2
    af_range: 2
    af_speed: 1

camera_gimbal:
  ros__parameters:
    i2c_bus: 1
    # Same controller as motors on Pi 5
    i2c_addr: 43  # 0x2B
    i2c_protocol: "auto"  # auto|pi5|legacy
    i2c_required: true
    dry_run: false

    # Yahboom servo IDs are typically 1 (pan) and 2 (tilt)
    pan_servo_id: 1
    tilt_servo_id: 2

    # Tune these for your physical neutral position
    pan_neutral_deg: 90.0
    tilt_neutral_deg: 45.0

    pan_min_deg: 0.0
    pan_max_deg: 180.0
    tilt_min_deg: 0.0
    # Conservative default for Pi 5 vendor protocol; increase if safe.
    tilt_max_deg: 110.0

    command_topic: "camera_gimbal/command_deg"
    startup_delay_sec: 1.0
    reset_on_startup: true
    reset_on_shutdown: true
    command_timeout_sec: 0.0
    publish_hz: 20.0
    # IMU tilt compensation: keeps camera level when robot pitches on inclines.
    imu_tilt_compensation: true
    imu_topic: "imu/data"
    imu_tilt_gain: 1.0          # 1.0 = fully compensate measured pitch
    imu_tilt_alpha: 0.85        # low-pass filter (0..1, higher = more smooth)
    imu_tilt_sign: 1.0          # flip if compensation goes the wrong way

lightbar:
  ros__parameters:
    i2c_bus: 1
    i2c_addr: 43  # 0x2B (same controller as motors)
    i2c_protocol: "auto"
    i2c_required: false
    dry_run: false
    command_topic: "lightbar/command"
    # Effect played on node start. Set to "none" to start dark.
    # Options: none, rainbow, breathing, chase
    startup_effect: "rainbow"
    startup_duration_sec: 3.0
    effect_fps: 30.0

imu_serial:
  ros__parameters:
    serial_port: "/dev/ttyACM0"
    baud_rate: 115200
    serial_timeout_sec: 2.0
    frame_id: "imu_link"
    publish_hz: 100.0
    # Always auto-calibrates gyro on every serial connection/reconnection.
    # This delay lets the Arduino + USB settle before sending the calibrate command.
    startup_calibrate_delay_sec: 1.0
    # Axis remapping: indices into raw [ax,ay,az]/[gx,gy,gz] arrays.
    # Adjust if the Arduino board is mounted in a non-standard orientation.
    # Default: board X→ROS X (forward), Y→Y (left), Z→Z (up).
    accel_axis_map: [0, 1, 2]
    accel_axis_sign: [1.0, 1.0, 1.0]
    gyro_axis_map: [0, 1, 2]
    gyro_axis_sign: [1.0, 1.0, 1.0]
    # Yaw integration (published on imu/yaw_deg)
    enable_yaw_integration: true
    yaw_gyro_axis: 2    # Z axis
    yaw_gyro_sign: 1.0
    # Noise / covariance (diagonal)
    accel_variance: 0.01
    gyro_variance: 0.001
    # BNO055 9-DOF (connected to Arduino A4/A5, firmware v2.0.0+)
    # When detected, imu/data carries fused quaternion and imu/yaw_deg
    # uses magnetometer-stabilised heading instead of drifting gyro yaw.
    orientation_variance: 0.0001    # BNO055 fused orientation is very accurate
    bno_cal_threshold: 1            # min system calibration (0-3) for calibrated=true
    heading_offset_deg: 0.0         # compass offset to align BNO055 north with robot forward

bno055_serial:
  ros__parameters:
    # USB serial port for the Pico RP2040 + BNO055 bridge.
    # Typically /dev/ttyACM1 if the Arduino Nano is on /dev/ttyACM0.
    # Use /dev/serial/by-id/... for a stable name:
    #   ls /dev/serial/by-id/  → look for "Raspberry_Pi_Pico"
    serial_port: "/dev/ttyACM1"
    baud_rate: 115200
    serial_timeout_sec: 2.0
    frame_id: "imu_link"
    # Minimum system calibration (0-3) to publish imu/calibrated=true
    cal_threshold: 1
    # Compass heading offset (degrees) to align BNO055 north with robot forward
    heading_offset_deg: 0.0
    # Covariance (diagonal). BNO055 fused orientation is very accurate.
    orientation_variance: 0.0001
    accel_variance: 0.01
    gyro_variance: 0.0001

oled:
  ros__parameters:
    enabled: true
    # Typical small OLEDs are SSD1306-compatible at I2C address 0x3C.
    i2c_bus: 1
    i2c_addr: 60  # 0x3C
    i2c_required: false
    dry_run: false
    width: 128
    height: 32
    rotate_180: false
    contrast: 127
    update_hz: 2.0

    # Text rendering. 8 is a good default for 128x32.
    font_size: 8
    # Leave empty to auto-pick a common system font.
    font_path: ""

    # If the OLED is blank/garbled, set this true once to cycle common configs
    # (128x64/128x32 and rotation) and pick what looks correct.
    startup_probe: false
    startup_probe_hold_sec: 2.0

    text_topic: "oled/text"
    ultrasonic_topic: "ultrasonic/range"
    cmd_vel_topic: "cmd_vel"
    show_ip: true

# ── Odometry (dead-reckoning + path recording + return-to-origin) ──
odometry:
  ros__parameters:
    odom_publish_hz: 20.0
    # Use BNO055 fused yaw for heading (much less drift than gyro integration)
    odom_use_imu_yaw: true
    odom_frame_id: "odom"
    odom_child_frame_id: "base_link"
    cmd_vel_topic: "cmd_vel"
    imu_topic: "imu/data"
    imu_yaw_topic: "imu/yaw_deg"
    # Velocity scale factors — calibrate for wheel slip / gear ratio mismatch.
    # Drive the robot a known distance (e.g. 1 m) and adjust these so
    # reported distance matches reality.  >1.0 = robot under-reports distance.
    odom_vx_scale: 1.0
    odom_vy_scale: 1.0
    # IMU-based Zero-Velocity Update (ZUPT) — prevents position drift when
    # the robot is physically stationary.  Uses BNO055 gravity-compensated
    # linear acceleration + gyro to detect stillness.
    odom_zupt_accel_threshold: 0.15   # m/s²  (XY accel EMA below this ≈ stationary)
    odom_zupt_gyro_threshold: 0.05    # rad/s  (gyro EMA below this ≈ not rotating)
    # Path recording: capture a waypoint every N metres or N radians of change
    odom_record_interval_m: 0.05
    odom_record_interval_rad: 0.10   # ~5.7 deg
    odom_max_waypoints: 5000
    # Publish the recorded path during recording at this rate for live visualisation
    odom_path_publish_hz: 2.0
    # Return-to-origin controller
    return_linear_speed: 0.15        # m/s
    return_angular_speed: 0.6        # rad/s
    return_goal_tolerance_m: 0.08    # how close to waypoint before advancing
    return_goal_tolerance_rad: 0.15  # ~8.6 deg final heading tolerance
    return_timeout_sec: 120.0        # abort return after this long
    return_cmd_vel_topic: "cmd_vel"

# ── LiDAR SLAM (occupancy grid mapping) ───────────────────────────
lidar_slam:
  ros__parameters:
    # Grid dimensions: 200×200 cells at 0.05m = 10m × 10m map area.
    # Origin at (−5, −5) centres the map on the robot's starting position.
    slam_resolution: 0.05          # metres per cell
    slam_width: 200                # cells
    slam_height: 200               # cells
    slam_origin_x: -5.0            # map origin X (metres)
    slam_origin_y: -5.0            # map origin Y (metres)

    # Update rates (keep low to save CPU on Pi 5)
    slam_update_hz: 2.0            # grid update rate (processes scans)
    slam_map_publish_hz: 1.0       # OccupancyGrid publish rate
    slam_tf_publish_hz: 10.0       # map→odom TF publish rate

    # Log-odds parameters for Bayesian occupancy update
    slam_log_odds_occ: 0.85        # evidence for occupied  (+)
    slam_log_odds_free: -0.40      # evidence for free      (−)
    slam_log_odds_max: 5.0         # saturation ceiling
    slam_log_odds_min: -2.0        # saturation floor
    slam_unknown_threshold: 0.15   # |log_odds| < this → unknown cell

    # Scan processing
    slam_min_range: 0.10           # ignore points closer than this (m)
    slam_max_range: 8.0            # ignore points farther than this (m)
    slam_scan_downsample: 3        # use every Nth scan point (1 = all)

    # Correlative scan-to-map matching (disabled by default — CPU intensive)
    # When enabled, the SLAM node refines the odometry pose by searching a
    # small window around the predicted position for the best scan match.
    # The correction is published as map→odom TF.
    slam_scan_match_enable: false
    slam_scan_match_min_scans: 20       # warmup before matching begins
    slam_scan_match_search_xy: 0.05     # ±m search window
    slam_scan_match_search_yaw: 0.035   # ±rad (~2°) search window
    slam_scan_match_step_xy: 0.01       # m step in search grid
    slam_scan_match_step_yaw: 0.005     # rad step (~0.3°)
    slam_scan_match_max_correction_xy: 0.02   # max correction per update (m)
    slam_scan_match_max_correction_yaw: 0.01  # max correction per update (rad)

    # Topics & frames
    scan_topic: "scan"
    odom_topic: "odom"
    map_topic: "map"
    map_frame_id: "map"
    odom_frame_id: "odom"

# ── LiDAR obstacle avoidance ──────────────────────────────────────
lidar_obstacle:
  ros__parameters:
    scan_topic: "scan"
    publish_hz: 10.0

    # Zone angular definitions (degrees from forward)
    front_half_angle_deg: 30.0      # front zone: ±30° from forward
    side_angle_start_deg: 30.0      # side zones: 30°–150°
    side_angle_end_deg: 150.0

    # Distance thresholds (metres)
    front_stop_distance: 0.20       # hard stop when front obstacle closer than this
    front_slow_distance: 0.50       # begin slow-down when closer than this
    side_stop_distance: 0.15        # hard stop for lateral movement
    side_slow_distance: 0.30        # begin lateral slow-down
    rear_stop_distance: 0.15        # hard stop for backward movement
    rear_slow_distance: 0.30        # begin backward slow-down

    # Range message parameters
    min_range: 0.05
    max_range: 12.0
    frame_id: "laser_frame"
